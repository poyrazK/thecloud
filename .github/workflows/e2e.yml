name: E2E Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  e2e:
    name: End-to-End Suite
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.24'
          cache: true

      - name: Setup Infrastructure
        env:
          DB_PORT_MAPPING: 5433:5432
          COMPOSE_PROJECT_NAME: thecloud-${{ github.run_id }}
          SECRETS_ENCRYPTION_KEY: abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789
          JWT_SECRET: e2e-test-secret-key-that-is-long-enough-for-32-chars
          DATABASE_READ_URL: postgres://cloud:cloud@postgres:5432/cloud?sslmode=disable
        run: |
          # Start internal dependencies
          docker compose up -d postgres redis jaeger
          
          # Wait for Postgres to be healthy
          until docker compose exec -T postgres pg_isready -U cloud; do
            echo "Waiting for postgres..."
            sleep 2
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build API
        uses: docker/build-push-action@v6
        with:
          context: .
          load: true
          tags: thecloud-api:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # The 'api' service in thecompose file already uses the latest build
      - name: Start API
        env:
          DB_PORT_MAPPING: 5433:5432
          COMPOSE_PROJECT_NAME: thecloud-${{ github.run_id }}
          DOCKER_DEFAULT_NETWORK: cloud-network
          SECRETS_ENCRYPTION_KEY: abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789
          JWT_SECRET: e2e-test-secret-key-that-is-long-enough-for-32-chars
          DATABASE_READ_URL: postgres://cloud:cloud@postgres:5432/cloud?sslmode=disable
          TRACING_ENABLED: false
        run: |
          # Export variables so docker-compose can access them
          export SECRETS_ENCRYPTION_KEY="${SECRETS_ENCRYPTION_KEY}"
          export JWT_SECRET="${JWT_SECRET}"
          export DATABASE_READ_URL="${DATABASE_READ_URL}"
          export TRACING_ENABLED="${TRACING_ENABLED}"
          export DB_PORT_MAPPING="${DB_PORT_MAPPING}"
          export COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME}"
          export DOCKER_DEFAULT_NETWORK="${DOCKER_DEFAULT_NETWORK}"

          # Ensure Docker socket has proper permissions for API to create containers
          sudo chmod 666 /var/run/docker.sock

          # Start API using the pulled/cached image
          docker compose up -d api
          
          # Wait for API to be ready
          echo "Waiting for API to be ready..."
          timeout 90 bash -c 'until curl -sf http://localhost:8080/health > /dev/null; do sleep 2; done' || {
            echo "API failed to start or become healthy within 90s"
            docker compose logs api
            exit 1
          }
          
          # Check if API is running
          docker compose ps

      - name: Run E2E Tests
        env:
          # The tests run on the HOST, connecting to the API at localhost:8080
          # So we use the mapped DB port 5433 for direct DB tests if any
          DATABASE_URL: postgres://cloud:cloud@localhost:5433/cloud?sslmode=disable
          TEST_DOCKER_NETWORK: cloud-network
          COMPOSE_PROJECT_NAME: thecloud-${{ github.run_id }}
        run: |
          # Run tests in parallel to achieve maximum speed.
          # The 'sync.Once' logic in helpers_test.go ensures they won't all wait redundantly.
          # We use -p 8 to allow high parallelism within the package.
          # 1. Run standard parallel tests (excluding chaos tests due to build tag)
          go test -v -p 8 -timeout 10m ./tests/...
          
          # 2. Run chaos tests sequentially (uses package path to include helpers)
          # Note: Chaos tests are destructive and restart containers, so they run last
          go test -v -tags=chaos -timeout 5m ./tests/...

      - name: Show API Logs on Failure
        if: failure()
        env:
          COMPOSE_PROJECT_NAME: thecloud-${{ github.run_id }}
        run: |
          docker compose logs api
          docker network ls
          docker ps -a


      - name: Debug Logs on Failure
        if: failure()
        run: |
          echo "Dumping container logs for debugging..."
          docker compose logs --tail=200
